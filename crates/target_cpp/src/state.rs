use jtd_codegen::target;
use std::collections::{BTreeMap, BTreeSet};
use std::fs::File;
use std::io::Write;
use std::path::Path;

use crate::props::CppProps;

pub struct CppEnum {}
pub struct CppStruct {}
pub struct CppAlias {}
pub struct CppDiscriminator {}
pub struct CppDiscriminatorVariant {}

pub enum CppTypes {
    Incomplete,
    Primitive(String),
    Array(usize),
    Dictionary(usize),
    Enum(CppEnum),
    Struct(CppStruct),
    Alias(CppAlias),
    Discriminator(CppDiscriminator),
    DiscriminatorVariant(CppDiscriminatorVariant),
}

#[derive(Default)]
pub struct CppState {
    // - header files to include, ex.: optional, vector, string, ...
    include_files: BTreeSet<String>,

    cpp_types: Vec<CppTypes>,
    cpp_type_indices: BTreeMap<String, usize>, // type name to index in "cpp_types"
}

impl CppState {
    pub fn write_header_file(
        &mut self,
        fname: &Path,
        props: &CppProps,
    ) -> jtd_codegen::Result<Option<String>> {
        let mut file = File::create(fname)?;

        let out: &mut dyn Write = &mut file;
        writeln!(
            out,
            "// Code generated by jtd-codegen for C++ v{}\n\n",
            env!("CARGO_PKG_VERSION")
        )?;

        out.write(props.get_guard().as_bytes())?;
        self.write_include_files(out)?;

        // ...

        out.write(props.get_footer().as_bytes())?;
        Ok(None)
    }

    fn check_and_add_primitive(&mut self, name: &str) -> usize {
        match self.cpp_type_indices.get(name) {
            Some(idx) => {
                if matches!(self.cpp_types[*idx], CppTypes::Incomplete) {
                    self.cpp_types[*idx] = CppTypes::Primitive(name.to_string());
                }
                *idx
            }
            None => {
                let idx = self.cpp_types.len();
                let sname = name.to_string();
                self.cpp_types.push(CppTypes::Primitive(sname.clone()));
                self.cpp_type_indices.insert(sname, idx);
                idx
            }
        }
    }

    fn check_and_add_incomplete(&mut self, name: &str) -> usize {
        match self.cpp_type_indices.get(name) {
            Some(idx) => *idx,
            None => {
                let idx = self.cpp_types.len();
                let sname = name.to_string();
                self.cpp_types.push(CppTypes::Incomplete);
                self.cpp_type_indices.insert(sname, idx);
                idx
            }
        }
    }

    // TODO: must retur the name
    pub fn add_primitive(&mut self, expr: target::Expr, props: &CppProps) {
        match expr {
            target::Expr::Boolean => self.check_and_add_primitive("bool"),
            target::Expr::Int8 => self.check_and_add_primitive("uint8_t"),
            target::Expr::Uint8 => self.check_and_add_primitive("uint8_t"),
            target::Expr::Int16 => self.check_and_add_primitive("uint16_t"),
            target::Expr::Uint16 => self.check_and_add_primitive("uint16_t"),
            target::Expr::Int32 => self.check_and_add_primitive("uint32_t"),
            target::Expr::Uint32 => self.check_and_add_primitive("uint32_t"),
            target::Expr::Float32 => self.check_and_add_primitive("float"),
            target::Expr::Float64 => self.check_and_add_primitive("double"),
            target::Expr::String => {
                self.add_include_file("string");
                self.check_and_add_primitive("std::string")
            }
            target::Expr::Timestamp => {
                // NOTHING FOR NOW, might have to include "chrono",
                1 // dummy value
            }
            target::Expr::ArrayOf(sub_expr) => {
                let name = format!("std::vector<{}>", sub_expr);
                match self.cpp_type_indices.get(&name) {
                    Some(idx) => *idx,
                    None => {
                        let sub_idx = self.check_and_add_incomplete(&sub_expr);
                        let idx = self.cpp_types.len();
                        self.cpp_types.push(CppTypes::Array(sub_idx));
                        self.cpp_type_indices.insert(name, idx);
                        idx
                    }
                }
            }
            target::Expr::DictOf(sub_expr) => {
                let (file, container) = props.get_dictionary_info();
                let name = format!("{}<std::string, {}>", container, sub_expr);
                match self.cpp_type_indices.get(&name) {
                    Some(idx) => *idx,
                    None => {
                        self.add_include_file("string");
                        self.add_include_file(file);

                        let sub_idx = self.check_and_add_incomplete(&sub_expr);
                        let idx = self.cpp_types.len();
                        self.cpp_types.push(CppTypes::Dictionary(sub_idx));
                        self.cpp_type_indices.insert(name, idx);
                        idx
                    }
                }
            }
            target::Expr::Empty => 4, // no idea what to do
            target::Expr::NullableOf(sub_expr) => {
                // no idea what to do yet
                5
            }
        };
    }

    pub fn add_include_file(&mut self, file: &str) {
        self.include_files.insert(file.to_string());
    }

    fn write_include_files(&self, out: &mut dyn Write) -> jtd_codegen::Result<Option<String>> {
        for h in &self.include_files {
            writeln!(out, "#include {}", h)?;
        }
        Ok(None)
    }
}
