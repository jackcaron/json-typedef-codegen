mod cpp_types;
pub mod props;
mod state;

use jtd_codegen::target::{self, inflect, metadata};
use lazy_static::lazy_static;
use props::CppProps;
use std::collections::BTreeSet;
use std::fs::File;
use std::io::Write;
use std::path::Path;

lazy_static! {
    static ref KEYWORDS: BTreeSet<String> = include_str!("keywords")
        .lines()
        .map(str::to_owned)
        .collect();
    static ref TYPE_NAMING_CONVENTION: Box<dyn inflect::Inflector + Send + Sync> =
        Box::new(inflect::KeywordAvoidingInflector::new(
            KEYWORDS.clone(),
            inflect::CombiningInflector::new(inflect::Case::pascal_case())
        ));
    static ref FIELD_NAMING_CONVENTION: Box<dyn inflect::Inflector + Send + Sync> =
        Box::new(inflect::KeywordAvoidingInflector::new(
            KEYWORDS.clone(),
            inflect::TailInflector::new(inflect::Case::snake_case())
        ));
    static ref ENUM_MEMBER_NAMING_CONVENTION: Box<dyn inflect::Inflector + Send + Sync> =
        Box::new(inflect::KeywordAvoidingInflector::new(
            KEYWORDS.clone(),
            inflect::TailInflector::new(inflect::Case::pascal_case())
        ));
}

fn write_codegen_version(out: &mut dyn Write) -> jtd_codegen::Result<Option<String>> {
    writeln!(
        out,
        "// Code generated by jtd-codegen for C++ v{}\n",
        env!("CARGO_PKG_VERSION")
    )?;
    Ok(None)
}

pub struct Target {
    props: CppProps,
    root_name: String,
}

impl Target {
    pub fn new(props: CppProps, root_name: String) -> Self {
        Self { props, root_name }
    }

    fn get_header_filename(&self) -> String {
        format!("{}.hpp", self.root_name)
    }

    fn write_source_file(
        &self,
        out: &mut dyn Write,
        state: &mut <Target as jtd_codegen::target::Target>::FileState,
    ) -> jtd_codegen::Result<Option<String>> {
        write_codegen_version(out)?;

        writeln!(out, "#include \"{}\"", self.get_header_filename())?;
        writeln!(out, "{}", state.write_src_include_files())?;
        writeln!(out, "{}", state.write_internal_code(&self.props))?;
        write!(out, "{}", self.props.open_namespace())?;

        write!(out, "{}", state.define(&self.props))?;

        writeln!(out, "{}", self.props.close_namespace())?;
        Ok(None)
    }

    fn write_header_file(
        &self,
        fname: &Path,
        state: &mut <Target as jtd_codegen::target::Target>::FileState,
    ) -> jtd_codegen::Result<Option<String>> {
        let mut file = File::create(fname)?;
        let out: &mut dyn Write = &mut file;

        write_codegen_version(out)?;

        write!(
            out,
            "{}{}\n{}",
            self.props.get_guard(),
            state.write_include_files(&self.props),
            self.props.open_namespace()
        )?;

        write!(
            out,
            "{}{}{}{}",
            state.write_forward_declarations(),
            state.write_alias(),
            state.declare(&self.props),
            state.prototype(&self.props)
        )?;

        write!(
            out,
            "\n\n{}\n{}",
            self.props.close_namespace(),
            self.props.get_footer()
        )?;
        Ok(None)
    }
}

impl jtd_codegen::target::Target for Target {
    type FileState = state::CppState;

    fn strategy(&self) -> target::Strategy {
        let fname = format!("{}.cpp", self.root_name);
        target::Strategy {
            file_partitioning: target::FilePartitioningStrategy::SingleFile(fname),
            enum_member_naming: target::EnumMemberNamingStrategy::Unmodularized,
            optional_property_handling: target::OptionalPropertyHandlingStrategy::WrapWithNullable,
            booleans_are_nullable: false,
            int8s_are_nullable: false,
            uint8s_are_nullable: false,
            int16s_are_nullable: false,
            uint16s_are_nullable: false,
            int32s_are_nullable: false,
            uint32s_are_nullable: false,
            float32s_are_nullable: false,
            float64s_are_nullable: false,
            strings_are_nullable: false,
            timestamps_are_nullable: false,
            arrays_are_nullable: false,
            dicts_are_nullable: false,
            aliases_are_nullable: false,
            enums_are_nullable: false,
            structs_are_nullable: false,
            discriminators_are_nullable: false,
        }
    }

    // copied from the Rust version
    fn name(&self, kind: target::NameableKind, parts: &[String]) -> String {
        match kind {
            target::NameableKind::Type => TYPE_NAMING_CONVENTION.inflect(parts),
            target::NameableKind::Field => FIELD_NAMING_CONVENTION.inflect(parts),
            target::NameableKind::EnumMember => ENUM_MEMBER_NAMING_CONVENTION.inflect(parts),
        }
    }

    fn expr(
        &self,
        state: &mut Self::FileState,
        metadata: metadata::Metadata,
        expr: target::Expr,
    ) -> String {
        state.parse_primitive(expr, &self.props, metadata)
    }

    fn item(
        &self,
        out: &mut dyn std::io::Write,
        state: &mut Self::FileState,
        item: target::Item,
    ) -> jtd_codegen::Result<Option<String>> {
        match item {
            target::Item::Auxiliary { out_dir } => self.write_header_file(
                out_dir.join(self.get_header_filename().as_str()).as_path(),
                state,
            ),
            target::Item::Preamble => Ok(None),
            target::Item::Postamble => self.write_source_file(out, state),

            target::Item::Alias {
                metadata,
                name,
                type_,
            } => {
                state.parse_alias(name, type_, metadata);
                Ok(None)
            }
            target::Item::Enum {
                metadata,
                name,
                members,
            } => {
                state.parse_enum(name, members, metadata);
                Ok(None)
            }
            target::Item::Struct {
                metadata,
                name,
                has_additional: _,
                fields,
            } => {
                state.parse_struct(name, fields, metadata);
                Ok(None)
            }
            target::Item::Discriminator {
                metadata,
                name,
                variants,
                tag_json_name,
                tag_field_name,
            } => {
                state.parse_discriminator(name, variants, tag_json_name, tag_field_name, metadata);
                Ok(None)
            }
            target::Item::DiscriminatorVariant {
                metadata,
                name,
                fields,
                tag_field_name,
                tag_json_name,
                tag_value,
                parent_name,
                has_additional: _,
            } => {
                state.parse_discriminator_variant(
                    name,
                    fields,
                    tag_field_name,
                    tag_json_name,
                    tag_value,
                    parent_name,
                    metadata,
                );
                Ok(None)
            }
        }
    }
}
