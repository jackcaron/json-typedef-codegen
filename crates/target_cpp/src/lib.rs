pub mod props;
mod state;

use jtd_codegen::target::{self, inflect, metadata};
use lazy_static::lazy_static;
use props::CppProps;
use std::collections::BTreeSet;
use std::fs::File;
use std::io::Write;
use std::path::Path;

lazy_static! {
    static ref KEYWORDS: BTreeSet<String> = include_str!("keywords")
        .lines()
        .map(str::to_owned)
        .collect();
    static ref TYPE_NAMING_CONVENTION: Box<dyn inflect::Inflector + Send + Sync> =
        Box::new(inflect::KeywordAvoidingInflector::new(
            KEYWORDS.clone(),
            inflect::CombiningInflector::new(inflect::Case::pascal_case())
        ));
    static ref FIELD_NAMING_CONVENTION: Box<dyn inflect::Inflector + Send + Sync> =
        Box::new(inflect::KeywordAvoidingInflector::new(
            KEYWORDS.clone(),
            inflect::TailInflector::new(inflect::Case::snake_case())
        ));
    static ref ENUM_MEMBER_NAMING_CONVENTION: Box<dyn inflect::Inflector + Send + Sync> =
        Box::new(inflect::KeywordAvoidingInflector::new(
            KEYWORDS.clone(),
            inflect::TailInflector::new(inflect::Case::pascal_case())
        ));
}

fn write_codegen_version(out: &mut dyn Write) -> jtd_codegen::Result<Option<String>> {
    writeln!(
        out,
        "// Code generated by jtd-codegen for C++ v{}\n",
        env!("CARGO_PKG_VERSION")
    )?;
    Ok(None)
}

pub struct Target {
    props: CppProps,
    root_name: String,
}

impl Target {
    pub fn new(props: CppProps, root_name: String) -> Self {
        Self { props, root_name }
    }

    fn get_header_filename(&self) -> String {
        format!("{}.hpp", self.root_name)
    }

    fn write_preamble(&self, out: &mut dyn Write) -> jtd_codegen::Result<Option<String>> {
        write_codegen_version(out)?;
        writeln!(out, "#include \"{}\"", self.get_header_filename())?;
        write!(out, "{}", self.props.open_namespace())?;
        Ok(None)
    }

    fn write_postamble(
        &self,
        out: &mut dyn Write,
        state: &mut <Target as jtd_codegen::target::Target>::FileState,
    ) -> jtd_codegen::Result<Option<String>> {
        // sort the CppTypes

        // start writing the functions, or could write everything in here instead

        writeln!(out, "{}", self.props.close_namespace())?;
        Ok(None)
    }

    fn write_header_file(
        &self,
        fname: &Path,
        state: &mut <Target as jtd_codegen::target::Target>::FileState,
    ) -> jtd_codegen::Result<Option<String>> {
        let mut file = File::create(fname)?;
        let out: &mut dyn Write = &mut file;

        write_codegen_version(out)?;

        out.write(self.props.get_guard().as_bytes())?;
        state.write_include_files(out)?;

        // ...

        out.write(self.props.get_footer().as_bytes())?;
        Ok(None)
    }
}

impl jtd_codegen::target::Target for Target {
    type FileState = state::CppState;

    fn strategy(&self) -> target::Strategy {
        let fname = format!("{}.cpp", self.root_name);
        target::Strategy {
            file_partitioning: target::FilePartitioningStrategy::SingleFile(fname),
            enum_member_naming: target::EnumMemberNamingStrategy::Unmodularized,
            optional_property_handling: target::OptionalPropertyHandlingStrategy::WrapWithNullable,
            booleans_are_nullable: false,
            int8s_are_nullable: false,
            uint8s_are_nullable: false,
            int16s_are_nullable: false,
            uint16s_are_nullable: false,
            int32s_are_nullable: false,
            uint32s_are_nullable: false,
            float32s_are_nullable: false,
            float64s_are_nullable: false,
            strings_are_nullable: false,
            timestamps_are_nullable: false,
            arrays_are_nullable: false,
            dicts_are_nullable: false,
            aliases_are_nullable: false,
            enums_are_nullable: false,
            structs_are_nullable: false,
            discriminators_are_nullable: false,
        }
    }

    // copied from the Rust version
    fn name(&self, kind: target::NameableKind, parts: &[String]) -> String {
        match kind {
            target::NameableKind::Type => TYPE_NAMING_CONVENTION.inflect(parts),
            target::NameableKind::Field => FIELD_NAMING_CONVENTION.inflect(parts),
            target::NameableKind::EnumMember => ENUM_MEMBER_NAMING_CONVENTION.inflect(parts),
        }
    }

    fn expr(
        &self,
        state: &mut Self::FileState,
        metadata: metadata::Metadata,
        expr: target::Expr,
    ) -> String {
        state.parse_primitive(expr, &self.props, metadata)
    }

    fn item(
        &self,
        out: &mut dyn std::io::Write,
        state: &mut Self::FileState,
        item: target::Item,
    ) -> jtd_codegen::Result<Option<String>> {
        match item {
            target::Item::Auxiliary { out_dir } => self.write_header_file(
                out_dir.join(self.get_header_filename().as_str()).as_path(),
                state,
            ),
            target::Item::Preamble => self.write_preamble(out),
            target::Item::Postamble => self.write_postamble(out, state),

            target::Item::Alias {
                metadata,
                name,
                type_,
            } => {
                state.parse_alias(name, type_, metadata);
                Ok(None)
            }
            target::Item::Enum {
                metadata,
                name,
                members,
            } => {
                println!("-- Enum {}", name);
                for member in &members {
                    println!("   - n: {}, j: {}", member.name, member.json_value);
                }
                Ok(None)
            }
            target::Item::Struct {
                metadata,
                name,
                has_additional: _,
                fields,
            } => Ok(None),
            target::Item::Discriminator {
                metadata,
                name,
                variants,
                tag_json_name,
                tag_field_name,
            } => Ok(None),
            target::Item::DiscriminatorVariant {
                metadata,
                name,
                fields,
                tag_field_name,
                tag_json_name,
                tag_value,
                parent_name,
                has_additional,
            } => Ok(None),
        }
    }
}
